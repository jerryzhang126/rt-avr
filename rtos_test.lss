
rtos_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000272  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  00000272  000002e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .eeprom       00000000  00810000  00810000  00000300  2**0
                  CONTENTS, READONLY
  3 .stab         00000cf0  00000000  00000000  00000300  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000040  00000000  00000000  00000ff0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__ctors_end>:
		sts \ioreg, \reg
	.endif
.endm

	;; Interrupt table only for atmega32
	jmp .L1  ; (RESET)
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end+0x54>
	INT_DEF INT0_VEC		; (INTO) External interrupt request 0
   4:	18 95       	reti
   6:	00 00       	nop
	INT_DEF INT1_VEC		; (INT1) External interrupt request 1
   8:	18 95       	reti
   a:	00 00       	nop
	INT_DEF INT2_VEC	; (INT2) External Interrupt request 2
   c:	18 95       	reti
   e:	00 00       	nop
	INT_DEF TIMER1_COMP_VEC		; (TIMER1 COMP)
  10:	18 95       	reti
  12:	00 00       	nop
	INT_DEF	TIMER2_COMP_VEC	; (TIMER2 OVF)
  14:	18 95       	reti
  16:	00 00       	nop
	INT_DEF	TIMER1_CAPT_VEC; (TIMER1 CAPT)
  18:	18 95       	reti
  1a:	00 00       	nop
	INT_DEF TIMER1_COMPA_VEC		; (TIMER1 COMPA)
  1c:	18 95       	reti
  1e:	00 00       	nop
	INT_DEF	TIMER1_COMPB_VEC	; (TIMER1 COMPB)
  20:	18 95       	reti
  22:	00 00       	nop
	INT_DEF	TIMER1_OVF_VEC	; (TIMER1 OVF)
  24:	18 95       	reti
  26:	00 00       	nop
	INT_DEF	TIMER0_COMP_VEC	; (TIMER0 COMP)
  28:	18 95       	reti
  2a:	00 00       	nop
	INT_DEF	TIMER0_OVF_VEC	; (TIMER0 OVF)
  2c:	18 95       	reti
  2e:	00 00       	nop
	INT_DEF	SPI_STC_VEC	; (SPI, STC) Serial Transfer Complete
  30:	18 95       	reti
  32:	00 00       	nop
	INT_DEF	USART_RXC_VEC	; (USART, RXC) USART, RX Complete
  34:	18 95       	reti
  36:	00 00       	nop
	INT_DEF	USART_UDRE_VEC	; (USART, UDRE) USART Data Register Empty
  38:	18 95       	reti
  3a:	00 00       	nop
	INT_DEF	USART_TXC_VEC	; (USART, TXC) USART, TX Complete
  3c:	18 95       	reti
  3e:	00 00       	nop
	INT_DEF	ADC_VEC	; (ADC) ADC Conversion complete
  40:	18 95       	reti
  42:	00 00       	nop
	INT_DEF	EE_RDY_VEC	; (EE_RDY) EEPROM READY
  44:	18 95       	reti
  46:	00 00       	nop
	INT_DEF	ANA_COMP_VEC	; (ANA_COMP) Analog comparator
  48:	18 95       	reti
  4a:	00 00       	nop
	INT_DEF	TWI_VEC	; (TWI) 2-wire Serial Interface
  4c:	18 95       	reti
  4e:	00 00       	nop
	INT_DEF	SPM_RDY_VEC	; (SPM_RDY) Store Program Memory Ready
  50:	18 95       	reti
  52:	00 00       	nop
;; Interrupts

;; End Interrupts

.L1:
	clr R0
  54:	00 24       	eor	r0, r0
	clr R1
  56:	11 24       	eor	r1, r1
	clr R2
  58:	22 24       	eor	r2, r2
	clr R3
  5a:	33 24       	eor	r3, r3
	clr R4
  5c:	44 24       	eor	r4, r4
	clr R5
  5e:	55 24       	eor	r5, r5
	clr R6
  60:	66 24       	eor	r6, r6
	clr R7
  62:	77 24       	eor	r7, r7
	clr R8
  64:	88 24       	eor	r8, r8
	clr R9
  66:	99 24       	eor	r9, r9
	clr R10
  68:	aa 24       	eor	r10, r10
	clr R11
  6a:	bb 24       	eor	r11, r11
	clr R12
  6c:	cc 24       	eor	r12, r12
	clr R13
  6e:	dd 24       	eor	r13, r13
	clr R14
  70:	ee 24       	eor	r14, r14
	clr R15
  72:	ff 24       	eor	r15, r15
	clr R16
  74:	00 27       	eor	r16, r16
	clr R17
  76:	11 27       	eor	r17, r17
	clr R18
  78:	22 27       	eor	r18, r18
	clr R19
  7a:	33 27       	eor	r19, r19
	clr R20
  7c:	44 27       	eor	r20, r20
	clr R21
  7e:	55 27       	eor	r21, r21
	clr R22
  80:	66 27       	eor	r22, r22
	clr R23
  82:	77 27       	eor	r23, r23
	clr R24
  84:	88 27       	eor	r24, r24
	clr R25
  86:	99 27       	eor	r25, r25
	clr XL
  88:	aa 27       	eor	r26, r26
	clr XH
  8a:	bb 27       	eor	r27, r27
	clr YL
  8c:	cc 27       	eor	r28, r28
	clr YH
  8e:	dd 27       	eor	r29, r29
	clr ZL
  90:	ee 27       	eor	r30, r30
	clr ZH
  92:	ff 27       	eor	r31, r31
	;; Init stack
	ldi R16, lo8(RAMEND)
  94:	0f e5       	ldi	r16, 0x5F	; 95
	out IOSPL, R16
  96:	0d bf       	out	0x3d, r16	; 61

	ldi R16, hi8(RAMEND)
  98:	08 e0       	ldi	r16, 0x08	; 8
	out IOSPH, R16
  9a:	0e bf       	out	0x3e, r16	; 62


	ldi ZL, lo8(RAMSTART)
  9c:	e0 e6       	ldi	r30, 0x60	; 96
	clr R16
  9e:	00 27       	eor	r16, r16

.L2:

	st Z+, R16
  a0:	01 93       	st	Z+, r16
	cpi ZH, hi8(RAMEND)
  a2:	f8 30       	cpi	r31, 0x08	; 8
	brne .L2
  a4:	e9 f7       	brne	.-6      	; 0xa0 <__ctors_end+0xa0>
	cpi ZL, lo8(RAMEND)
  a6:	ef 35       	cpi	r30, 0x5F	; 95
	brne .L2
  a8:	d9 f7       	brne	.-10     	; 0xa0 <__ctors_end+0xa0>

	clr ZL
  aa:	ee 27       	eor	r30, r30
	clr ZH
  ac:	ff 27       	eor	r31, r31
	out IOSREG, R16			; Инициализация SREG 
  ae:	0f bf       	out	0x3f, r16	; 63

.ifdef RESET_VEC
	rjmp RESET_VEC
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <RESET_VEC>

000000b2 <RESET_VEC>:
.section .text
.include "startup.asm"


main:
	rcall RT_Init
  b2:	2f d0       	rcall	.+94     	; 0x112 <RT_Init>

    ldi R16, 0b00000011
  b4:	03 e0       	ldi	r16, 0x03	; 3
    out DDRD, R16     
  b6:	01 bf       	out	0x31, r16	; 49
	ldi R16, 0b00000000
  b8:	00 e0       	ldi	r16, 0x00	; 0
	out PORTD, R16
  ba:	02 bf       	out	0x32, r16	; 50

	RT_TIMER 2, 50 
  bc:	12 e0       	ldi	r17, 0x02	; 2
  be:	a2 e3       	ldi	r26, 0x32	; 50
  c0:	b0 e0       	ldi	r27, 0x00	; 0
  c2:	b0 d0       	rcall	.+352    	; 0x224 <RT_SetTimer>
	RT_TIMER 1, 70 
  c4:	11 e0       	ldi	r17, 0x01	; 1
  c6:	a6 e4       	ldi	r26, 0x46	; 70
  c8:	b0 e0       	ldi	r27, 0x00	; 0
  ca:	ac d0       	rcall	.+344    	; 0x224 <RT_SetTimer>
	rcall RT_TimerInterrupt
  cc:	30 d0       	rcall	.+96     	; 0x12e <RT_TimerInterrupt>
	rcall RT_TimerInterrupt
  ce:	2f d0       	rcall	.+94     	; 0x12e <RT_TimerInterrupt>
	rcall RT_TimerInterrupt
  d0:	2e d0       	rcall	.+92     	; 0x12e <RT_TimerInterrupt>
	rcall RT_TimerInterrupt
  d2:	2d d0       	rcall	.+90     	; 0x12e <RT_TimerInterrupt>
	rcall RT_TimerInterrupt
  d4:	2c d0       	rcall	.+88     	; 0x12e <RT_TimerInterrupt>
	rjmp RT_Start
  d6:	29 c0       	rjmp	.+82     	; 0x12a <RT_Start>

000000d8 <RT_TaskProcs>:
  d8:	e0 00       	.word	0x00e0	; ????
  da:	e2 00       	.word	0x00e2	; ????
  dc:	ee 00       	.word	0x00ee	; ????
  de:	fa 00       	.word	0x00fa	; ????

000000e0 <Idle>:
	.word Task1
	.word Task2
	.word Task3

Idle:
	ret
  e0:	08 95       	ret

000000e2 <Task1>:
Task1:
	sbi IOPORTD, 0
  e2:	90 9a       	sbi	0x12, 0	; 18
	RT_TIMER 3, 123 
  e4:	13 e0       	ldi	r17, 0x03	; 3
  e6:	ab e7       	ldi	r26, 0x7B	; 123
  e8:	b0 e0       	ldi	r27, 0x00	; 0
  ea:	9c d0       	rcall	.+312    	; 0x224 <RT_SetTimer>
	ret
  ec:	08 95       	ret

000000ee <Task2>:
Task2:
	sbi IOPORTD, 1
  ee:	91 9a       	sbi	0x12, 1	; 18
	RT_TIMER 4, 351
  f0:	14 e0       	ldi	r17, 0x04	; 4
  f2:	af e5       	ldi	r26, 0x5F	; 95
  f4:	b1 e0       	ldi	r27, 0x01	; 1
  f6:	96 d0       	rcall	.+300    	; 0x224 <RT_SetTimer>
	ret
  f8:	08 95       	ret

000000fa <Task3>:
Task3:
	cbi IOPORTD, 0
  fa:	90 98       	cbi	0x12, 0	; 18
	RT_TIMER 1, 212
  fc:	11 e0       	ldi	r17, 0x01	; 1
  fe:	a4 ed       	ldi	r26, 0xD4	; 212
 100:	b0 e0       	ldi	r27, 0x00	; 0
 102:	90 d0       	rcall	.+288    	; 0x224 <RT_SetTimer>
	ret
 104:	08 95       	ret

00000106 <Task4>:
Task4:
	cbi IOPORTD, 1
 106:	91 98       	cbi	0x12, 1	; 18
	RT_TIMER 2, 211
 108:	12 e0       	ldi	r17, 0x02	; 2
 10a:	a3 ed       	ldi	r26, 0xD3	; 211
 10c:	b0 e0       	ldi	r27, 0x00	; 0
 10e:	8a d0       	rcall	.+276    	; 0x224 <RT_SetTimer>
	ret
 110:	08 95       	ret

00000112 <RT_Init>:
RT_TimersPool:
	.skip RT_TimersPoolSize*3

.section .text
RT_Init:
		rcall RT_ClearTimers		; Очистить список таймеров РТОС
 112:	3f d0       	rcall	.+126    	; 0x192 <RT_ClearTimers>
		rcall RT_ClearTaskQueue	; Очистить очередь событий РТОС
 114:	32 d0       	rcall	.+100    	; 0x17a <RT_ClearTaskQueue>

		; Init Timer 2
		; Основной таймер для ядра РТОС

		ldi RT_RG,1<<WGM21|4<<CS20	; Freq = CK/64 - Установить режим и предделитель
 116:	1c e0       	ldi	r17, 0x0C	; 12
		out IOTCCR2, RT_RG				; Автосброс после достижения регистра сравнения
 118:	15 bd       	out	0x25, r17	; 37

		clr RT_RG					; Установить начальное значение счётчиков
 11a:	11 27       	eor	r17, r17
		out IOTCNT2, RT_RG				;	
 11c:	14 bd       	out	0x24, r17	; 36

		ldi RT_RG, lo8(RT_TimerDivider)
 11e:	1d e7       	ldi	r17, 0x7D	; 125
		out IOOCR2, RT_RG				; Установить значение в регистр сравнения
 120:	13 bd       	out	0x23, r17	; 35
		ldi RT_RG, 1<<7 
 122:	10 e8       	ldi	r17, 0x80	; 128
		out IOTIMSK, RT_RG
 124:	19 bf       	out	0x39, r17	; 57
		sei						; Разрешить обработку прерываний
 126:	78 94       	sei
		ret
 128:	08 95       	ret

0000012a <RT_Start>:

RT_Start:

		# wdr
		rcall RT_ProcessTaskQueue
 12a:	42 d0       	rcall	.+132    	; 0x1b0 <RT_ProcessTaskQueue>
		rjmp RT_Start
 12c:	fe cf       	rjmp	.-4      	; 0x12a <RT_Start>

0000012e <RT_TimerInterrupt>:

RT_TimerInterrupt:
			push 	RT_RG
 12e:	1f 93       	push	r17
			in 		RT_RG, IOSREG		; Save Sreg
 130:	1f b7       	in	r17, 0x3f	; 63
			push 	RT_RG				; Сохранение регистра RT_RG и регистра состояния SREG
 132:	1f 93       	push	r17

			push 	ZL	
 134:	ef 93       	push	r30
			push 	ZH					; сохранение Регистра Z
 136:	ff 93       	push	r31
			push 	Counter				; сохранение Регистра Counter
 138:	0f 93       	push	r16
	
			ldi 	ZL, lo8(RT_TimersPool)	; Загрузка с регистр Z адреса RAM, 
 13a:	eb e6       	ldi	r30, 0x6B	; 107
			ldi 	ZH, hi8(RT_TimersPool) ; по которому находится информация о таймерах
 13c:	f0 e0       	ldi	r31, 0x00	; 0

			ldi 	Counter, RT_TimersPoolSize ; максимальное количество таймеров
 13e:	05 e0       	ldi	r16, 0x05	; 5
	
.LComp1L01:	ld 		RT_RG, Z				; RT_RG = [Z] ; Получить номер события
 140:	10 81       	ld	r17, Z
			cpi 	RT_RG, 0xFF			; Проверить на "NOP"
 142:	1f 3f       	cpi	r17, 0xFF	; 255
			breq 	.LComp1L03			; Если NOP то переход к следующей позиции
 144:	79 f0       	breq	.+30     	; 0x164 <RT_TimerInterrupt+0x36>

			clt							; Флаг T используется для сохранения информации об окончании счёта
 146:	e8 94       	clt
			ldd 	RT_RG, Z+1			; 
 148:	11 81       	ldd	r17, Z+1	; 0x01
			subi 	RT_RG, lo8(1) 		; Уменьшение младшей части счётчика на 1
 14a:	11 50       	subi	r17, 0x01	; 1
			std 	Z+1, RT_RG			;
 14c:	11 83       	std	Z+1, r17	; 0x01
			breq 	.LComp1L02			; Если 0 то флаг T не устанавливаем
 14e:	09 f0       	breq	.+2      	; 0x152 <RT_TimerInterrupt+0x24>
			set							; 
 150:	68 94       	set

.LComp1L02:	ldd 	RT_RG, Z+2			;
 152:	12 81       	ldd	r17, Z+2	; 0x02
			sbci 	RT_RG, hi8(1) 		; Уменьшение старшей части счётчика на 1
 154:	10 40       	sbci	r17, 0x00	; 0
			std 	Z+2, RT_RG			;
 156:	12 83       	std	Z+2, r17	; 0x02
			brne 	.LComp1L03			; Счёт не окончен
 158:	29 f4       	brne	.+10     	; 0x164 <RT_TimerInterrupt+0x36>
			brts 	.LComp1L03			; Счёт не окончен (по T)	
 15a:	26 f0       	brts	.+8      	; 0x164 <RT_TimerInterrupt+0x36>
	
			ld 		RT_RG, Z				; Получить номер события
 15c:	10 81       	ld	r17, Z
			rcall 	RT_SendTask			; послать в системную очередь задач
 15e:	4f d0       	rcall	.+158    	; 0x1fe <RT_SendTask>
	
			ldi 	RT_RG, 0xFF			; = NOP (задача выполнена, таймер самоудаляется)
 160:	1f ef       	ldi	r17, 0xFF	; 255
			st 		Z, RT_RG				; Clear Event
 162:	10 83       	st	Z, r17

.LComp1L03:	subi 	ZL, lo8(-3)			; Skip Counter
 164:	ed 5f       	subi	r30, 0xFD	; 253
			sbci 	ZH, hi8(-3)			; Z+=3 - переход к следующему таймеру
 166:	ff 4f       	sbci	r31, 0xFF	; 255
			dec 	Counter				; счетчик таймеров
 168:	0a 95       	dec	r16
			brne 	.LComp1L01			; Loop	
 16a:	51 f7       	brne	.-44     	; 0x140 <RT_TimerInterrupt+0x12>

			pop 	Counter				; восстанавливаем переменные
 16c:	0f 91       	pop	r16
			pop 	ZH
 16e:	ff 91       	pop	r31
			pop 	ZL
 170:	ef 91       	pop	r30

			pop 	RT_RG				; Восстанавливаем регистры
 172:	1f 91       	pop	r17
			out 	IOSREG, RT_RG			; 
 174:	1f bf       	out	0x3f, r17	; 63
			pop 	RT_RG
 176:	1f 91       	pop	r17
			reti
 178:	18 95       	reti

0000017a <RT_ClearTaskQueue>:


RT_ClearTaskQueue:
		push 	ZL
 17a:	ef 93       	push	r30
		push 	ZH
 17c:	ff 93       	push	r31

		ldi 	ZL, lo8(RT_TaskQueue)
 17e:	e0 e6       	ldi	r30, 0x60	; 96
		ldi 	ZH, hi8(RT_TaskQueue)
 180:	f0 e0       	ldi	r31, 0x00	; 0

		ldi 	RT_RG, 0xFF		
 182:	1f ef       	ldi	r17, 0xFF	; 255
		ldi 	Counter, RT_TaskQueueSize
 184:	0b e0       	ldi	r16, 0x0B	; 11

.LCEQL01: 
		st 		Z+, RT_RG		;
 186:	11 93       	st	Z+, r17
		dec 	Counter		;
 188:	0a 95       	dec	r16
		brne 	.LCEQL01		; Loop
 18a:	e9 f7       	brne	.-6      	; 0x186 <RT_ClearTaskQueue+0xc>

		pop 	ZH
 18c:	ff 91       	pop	r31
		pop 	ZL
 18e:	ef 91       	pop	r30
		ret
 190:	08 95       	ret

00000192 <RT_ClearTimers>:
	
RT_ClearTimers:
		push 	ZL
 192:	ef 93       	push	r30
		push 	ZH
 194:	ff 93       	push	r31

		ldi 	ZL, lo8(RT_TimersPool)
 196:	eb e6       	ldi	r30, 0x6B	; 107
		ldi 	ZH, hi8(RT_TimersPool)
 198:	f0 e0       	ldi	r31, 0x00	; 0

		ldi 	Counter, RT_TimersPoolSize
 19a:	05 e0       	ldi	r16, 0x05	; 5
		ldi 	RT_RG, 0xFF		; Empty 
 19c:	1f ef       	ldi	r17, 0xFF	; 255
		ldi 	Tmp2, 0x00
 19e:	20 e0       	ldi	r18, 0x00	; 0

.LCTL01:	
		st 		Z+, RT_RG		; Event
 1a0:	11 93       	st	Z+, r17
		st 		Z+, Tmp2		; Counter Lo
 1a2:	21 93       	st	Z+, r18
		st 		Z+, Tmp2		; Counter Hi
 1a4:	21 93       	st	Z+, r18

		dec 	Counter		;
 1a6:	0a 95       	dec	r16
		brne 	.LCTL01		; Loop
 1a8:	d9 f7       	brne	.-10     	; 0x1a0 <RT_ClearTimers+0xe>
	
		pop 	ZH
 1aa:	ff 91       	pop	r31
		pop 	ZL
 1ac:	ef 91       	pop	r30
		ret	
 1ae:	08 95       	ret

000001b0 <RT_ProcessTaskQueue>:




RT_ProcessTaskQueue:
		ldi 	ZL, lo8(RT_TaskQueue)
 1b0:	e0 e6       	ldi	r30, 0x60	; 96
		ldi 	ZH, hi8(RT_TaskQueue)
 1b2:	f0 e0       	ldi	r31, 0x00	; 0

		ld 		RT_RG, Z		; For Event
 1b4:	10 81       	ld	r17, Z
		cpi 	RT_RG, 0xFF	; No Event or Addr out of Range
 1b6:	1f 3f       	cpi	r17, 0xFF	; 255
		breq 	.LPTQL02		; No Action
 1b8:	09 f1       	breq	.+66     	; 0x1fc <RT_ProcessTaskQueue+0x4c>
	
		clr 	ZH
 1ba:	ff 27       	eor	r31, r31
		lsl 	RT_RG
 1bc:	11 0f       	add	r17, r17
		mov 	ZL, RT_RG
 1be:	e1 2f       	mov	r30, r17

		
		ldi 	RT_RG, lo8(RT_TaskProcs)
 1c0:	18 ed       	ldi	r17, 0xD8	; 216
		add 	ZL, RT_RG
 1c2:	e1 0f       	add	r30, r17
		ldi		RT_RG, hi8(RT_TaskProcs)
 1c4:	10 e0       	ldi	r17, 0x00	; 0
		adc		ZH, RT_RG 
 1c6:	f1 1f       	adc	r31, r17

		lpm					; mov r0 <- CODE[Z]
 1c8:	c8 95       	lpm
		mov 	RT_RG, r0
 1ca:	10 2d       	mov	r17, r0
		ld 		r0, Z+			; inc Z
 1cc:	01 90       	ld	r0, Z+
		lpm	
 1ce:	c8 95       	lpm
		mov 	ZL, RT_RG		; Get Addr
 1d0:	e1 2f       	mov	r30, r17
		mov 	ZH, r0
 1d2:	f0 2d       	mov	r31, r0
	
		push 	ZL
 1d4:	ef 93       	push	r30
		push 	ZH
 1d6:	ff 93       	push	r31

; Advance Queue
		ldi 	Counter, RT_TaskQueueSize-1
 1d8:	0a e0       	ldi	r16, 0x0A	; 10
		ldi 	ZL, lo8(RT_TaskQueue)
 1da:	e0 e6       	ldi	r30, 0x60	; 96
		ldi 	ZH, hi8(RT_TaskQueue)
 1dc:	f0 e0       	ldi	r31, 0x00	; 0
	
		cli
 1de:	f8 94       	cli
	
.LPTQL01:	
		ldd 	RT_RG, Z+1 		;	Shift Queues
 1e0:	11 81       	ldd	r17, Z+1	; 0x01
		st 		Z+, RT_RG		
 1e2:	11 93       	st	Z+, r17

		dec 	Counter		
 1e4:	0a 95       	dec	r16
		brne 	.LPTQL01		; Loop
 1e6:	e1 f7       	brne	.-8      	; 0x1e0 <RT_ProcessTaskQueue+0x30>
		ldi 	RT_RG, 0xFF	
 1e8:	1f ef       	ldi	r17, 0xFF	; 255
		st 		Z+, RT_RG		
 1ea:	11 93       	st	Z+, r17
	
		sei
 1ec:	78 94       	sei

		pop 	ZH
 1ee:	ff 91       	pop	r31
		pop 	ZL
 1f0:	ef 91       	pop	r30
		clc
 1f2:	88 94       	clc
		ror ZH
 1f4:	f7 95       	ror	r31
		ror ZL
 1f6:	e7 95       	ror	r30
		clc
 1f8:	88 94       	clc
		ijmp 			; Minimize Stack Usage
 1fa:	09 94       	ijmp
	
.LPTQL02:	
		ret	
 1fc:	08 95       	ret

000001fe <RT_SendTask>:


;-------------------------------------------------------------------------
; RT_RG - Event
RT_SendTask:
		push 	ZL
 1fe:	ef 93       	push	r30
		push 	ZH
 200:	ff 93       	push	r31
		push 	Tmp2
 202:	2f 93       	push	r18
		push 	Counter
 204:	0f 93       	push	r16

		ldi 	ZL,lo8(RT_TaskQueue)
 206:	e0 e6       	ldi	r30, 0x60	; 96
		ldi 	ZH,hi8(RT_TaskQueue)
 208:	f0 e0       	ldi	r31, 0x00	; 0

		ldi 	Counter, RT_TaskQueueSize
 20a:	0b e0       	ldi	r16, 0x0B	; 11

.LSEQL01: 
		ld 		Tmp2, Z+
 20c:	21 91       	ld	r18, Z+

		cpi 	Tmp2, 0xFF
 20e:	2f 3f       	cpi	r18, 0xFF	; 255
		breq 	.LSEQL02
 210:	19 f0       	breq	.+6      	; 0x218 <RT_SendTask+0x1a>

		dec 	Counter		;
 212:	0a 95       	dec	r16
		breq 	.LSEQL03		; Loop
 214:	11 f0       	breq	.+4      	; 0x21a <RT_SendTask+0x1c>
		rjmp 	.LSEQL01
 216:	fa cf       	rjmp	.-12     	; 0x20c <RT_SendTask+0xe>

.LSEQL02: 
		st 		-Z, RT_RG	; Store Task
 218:	12 93       	st	-Z, r17



.LSEQL03:					; EXIT
		pop 	Counter
 21a:	0f 91       	pop	r16
		pop 	Tmp2
 21c:	2f 91       	pop	r18
		pop 	ZH
 21e:	ff 91       	pop	r31
		pop 	ZL
 220:	ef 91       	pop	r30
		ret	
 222:	08 95       	ret

00000224 <RT_SetTimer>:
;------------------------------------------------------------------------	
; RT_RG - Timer Event
; X - Counter
RT_SetTimer:
		push 	ZL
 224:	ef 93       	push	r30
		push 	ZH
 226:	ff 93       	push	r31
		push 	Tmp2
 228:	2f 93       	push	r18
		push 	Counter
 22a:	0f 93       	push	r16

		ldi 	ZL, lo8(RT_TimersPool)
 22c:	eb e6       	ldi	r30, 0x6B	; 107
		ldi 	ZH, hi8(RT_TimersPool)
 22e:	f0 e0       	ldi	r31, 0x00	; 0

		ldi 	Counter, RT_TimersPoolSize
 230:	05 e0       	ldi	r16, 0x05	; 5
	
.LSTL01: 
		ld 		Tmp2, Z		; Value / Counter
 232:	20 81       	ld	r18, Z
		cp 		Tmp2, RT_RG		; Search for Event
 234:	21 17       	cp	r18, r17
		breq 	.LSTL02
 236:	29 f0       	breq	.+10     	; 0x242 <RT_SetTimer+0x1e>
	
		subi 	ZL, lo8(-3)	; Skip Counter
 238:	ed 5f       	subi	r30, 0xFD	; 253
		sbci 	ZH, hi8(-3)	; Z+=2
 23a:	ff 4f       	sbci	r31, 0xFF	; 255

		dec 	Counter		;
 23c:	0a 95       	dec	r16
		breq 	.LSTL03		; Loop
 23e:	21 f0       	breq	.+8      	; 0x248 <RT_SetTimer+0x24>
		rjmp 	.LSTL01
 240:	f8 cf       	rjmp	.-16     	; 0x232 <RT_SetTimer+0xe>
	
.LSTL02:	;cli
		std 	Z+1, XL		; Critical Section
 242:	a1 83       	std	Z+1, r26	; 0x01
		std 	Z+2, XH		; Update Counter
 244:	b2 83       	std	Z+2, r27	; 0x02
		;sei				; leave Critical Section
		rjmp	.LSTL06		; Exit
 246:	10 c0       	rjmp	.+32     	; 0x268 <RT_SetTimer+0x44>
.LSTL03:

		ldi 	ZL, lo8(RT_TimersPool)
 248:	eb e6       	ldi	r30, 0x6B	; 107
		ldi 	ZH, hi8(RT_TimersPool)
 24a:	f0 e0       	ldi	r31, 0x00	; 0

		ldi 	Counter, RT_TimersPoolSize
 24c:	05 e0       	ldi	r16, 0x05	; 5
	
.LSTL04:	
		ld 		Tmp2, Z		; Value / Counter
 24e:	20 81       	ld	r18, Z
		cpi 	Tmp2, 0xFF		; Search for Empty Timer
 250:	2f 3f       	cpi	r18, 0xFF	; 255
		breq 	.LSTL05
 252:	29 f0       	breq	.+10     	; 0x25e <RT_SetTimer+0x3a>
	
		subi 	ZL, lo8(-3)	; Skip Counter
 254:	ed 5f       	subi	r30, 0xFD	; 253
		sbci 	ZH, hi8(-3)	; Z+=2
 256:	ff 4f       	sbci	r31, 0xFF	; 255

		dec 	Counter		;
 258:	0a 95       	dec	r16
		breq 	.LSTL06		; No Empty Timer
 25a:	31 f0       	breq	.+12     	; 0x268 <RT_SetTimer+0x44>
		rjmp 	.LSTL04
 25c:	f8 cf       	rjmp	.-16     	; 0x24e <RT_SetTimer+0x2a>
	
.LSTL05:	
		cli
 25e:	f8 94       	cli
		st 		Z, RT_RG		; Set Event 
 260:	10 83       	st	Z, r17
		std 	Z+1, XL
 262:	a1 83       	std	Z+1, r26	; 0x01
		std 	Z+2, XH
 264:	b2 83       	std	Z+2, r27	; 0x02
		sei
 266:	78 94       	sei

.LSTL06:
		pop 	Counter
 268:	0f 91       	pop	r16
		pop 	Tmp2
 26a:	2f 91       	pop	r18
		pop 	ZH
 26c:	ff 91       	pop	r31
		pop 	ZL
 26e:	ef 91       	pop	r30
		ret
 270:	08 95       	ret
